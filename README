This project is an Independent Study to develop a compiler/interpreter/etc.


The language followed by the current master is described by:

<stmts>     ::= <stmt> <stmts> | empty
<stmt>      ::= <output> | <impdec> | <expdec> | <assign> | <cond> | <loop>
<output>    ::= PRINT LPAREN <expr> RPAREN SEMICOLON | PRINTLN LPAREN <expr> RPAREN SEMICOLON
<input>     ::= READINT LPAREN STRING RPAREN | READSTR LPAREN STRING RPAREN
<impdec>    ::= VAR ID ASSIGN <expr> SEMICOLON
<expdec>    ::= <type> <subtype> ID
<expdect>   ::= SEMICOLON | ASSIGN <expr> SEMICOLON
<assign>    ::= ID <listindex> ASSIGN <expr> SEMICOLON
<listindex> ::= LBRACKET <expr> RBRACKET | empty
<type>      ::= INT | STRING | BOOL
<subtype>   ::= LBRACKET RBRACKET | empty
<expr>      ::= <value> <exprt>
<exprt>     ::= <math_rel> <expr> | empty
<value>     ::= ID <listindex> | STRING | INT | BOOL | <input> | LBRACKET <exprlist> RBRACKET
<exprlist>  ::= <expr> <exprtail> | empty
<exprtail>  ::= COMMA <expr> <exprtail> | empty
<math_rel>  ::= PLUS | MINUS | DIVIDE | MULTIPLY
<cond>      ::= IF <ifstmt> <condt> END
<condt>     ::= ELIF <ifstmt> <condt> | ELSE <stmts> | empty
<ifstmt>    ::= <bexpr> THEN <stmts>
<bexpr>     ::= <expr> <bexprt> | NOT <expr> <bexprt>
<bexprt>    ::= <bool_rel> <expr> <bconnct> | empty
<bconnct>   ::= AND <bexpr> | OR <bexpr> | empty
<bool_rel>  ::= EQUAL | LESS_THAN | GREATER_THAN | LESS_THAN_EQUAL | GREATER_THAN_EQUAL | NOT_EQUAL


To build:
1. Open the accompanying Code::Blocks project and build it there. (Recommended for Windows users)
2. Utilize the accompanying makefile. (Recommended for Unix users, but using Code::Blocks is cool, too)


How to use:
  LexicalAnalyzer [options] file [file file ...]
  Options:
    -o <filename> : All output (except errors) is piped to the specified filename.
    -p            : Parse-only. Just checks syntax.
    -no-print     : Does not print out the AST after it is created.


Runtime errors:
1. If the syntax of the input file is definitely correct, but there is still a syntax error being thrown, then it is likely to do with the line endings. The program expects Unix style-endings, but Windows-style may be present. Use d2u, dos2unix, or sed to modify the input file to Unix-style line endings.

Type Evaluations:
-All type relations that are not defined here will result in error.

x::int, y::int =>
  (x + y) :: int
  (x - y) :: int
  (x * y) :: int
  (x / y) :: int
  (y > x) :: boolean
  (x >= y) :: boolean
  (y < x) :: boolean
  (x <= y) :: boolean
  (y == x) :: boolean
  (x != y) :: boolean

x::string, y::string =>
  (x + y) :: string
  (x - y) :: error
  (x * y) :: error
  (x / y) :: error
  (y > x) :: boolean
  (x >= y) :: boolean
  (y < x) :: boolean
  (x <= y) :: boolean
  (y == x) :: boolean
  (x != y) :: boolean

x::boolean, y::boolean =>
  (x + y) :: boolean
  (x - y) :: boolean
  (x * y) :: error
  (x / y) :: error

x::int, y::string =>
  (x + y) :: error
  (y + x) :: string
  (x - y) :: error
  (y - x) :: error
  (x * y) :: error
  (y * x) :: string
  (x / y) :: error
  (y / x) :: error

x::int, y::boolean =>
  (x + y) :: error
  (y + x) :: error
  (x - y) :: error
  (y - x) :: error
  (x * y) :: error
  (y * x) :: error
  (x / y) :: error
  (y / x) :: error

x::string, y::boolean =>
  (x + y) :: error
  (y + x) :: string
  (x - y) :: error
  (y - x) :: error
  (x * y) :: error
  (y * x) :: string
  (x / y) :: error
  (y / x) :: error

x::[int], i::int =>
  x[i] :: int
  (x + i) :: error
  (x - i) :: error
  (x * i) :: error
  (x / i) :: error

x::[string], i::int =>
  x[i] :: string
  (x + i) :: error
  (x - i) :: error
  (x * i) :: error
  (x / i) :: error

x::[boolean], i::int =>
  x[i] :: boolean
  (x + i) :: error
  (x - i) :: error
  (x * i) :: error
  (x / i) :: error
